Экзамен строится в два этапа. Теория и практика. Практика будет использоваться чтобы разграничить оценки от 3 до 5.
Теорию и практику можно сдавать в разные дни.
Теория:
Ответить на 2-3 вопросов из списка.
1)Классификация Флинна и SIMT
2)GPGPU и CUDA, система отложенных задач
3)Сборка программы через nvcc, гибридная сборка, линковка с использованием g++, понятие о jit компиляции
4)Многопоточность, понятие thread, block, grid. Понятие stream и warp
5)Спецификаторы функций, спецификаторы переменных, типы памяти
6)Архитектура GPU, архитектура SM
7)Глобальная память, L1/L2 и coalesced запросы
8)DeviceQuery и расшифровка понятий (Maximum number of threads per block, Maximum number of threads per multiprocessor, Max dimension size of a thread block (x,y,z) ).
9)Occupancy и Limiters
10)Выделение памяти в DRAM (динамическое, статическое, статическое из ядер)
11)Shared memory, банки памяти, работа с double и выравнивание памяти
12)Pinned memory типы, способ создания, принцип применения
13)Текстурная память, константная память, применение

Практика. 
Выбираем задачу (на 4 или на 5). Задачу на 4 необходимо решить полностью, задачу на 5 можно недорешать и получить 4.
Задачи на 4-ку строяться из материала который был изучен на практике, на 5-ку добавляються темы: многопоточность(stream), асинхронное копирование памяти, выделение shared памяти динамически, pinned memory

Пример на 4.
Дана сетка. Каждый узел сетки представлен в виде структуры { x, y , value }, Значения на границах сетки равны 0, так-же заданы координаты трёх квадратов(диагоналями) со значениями 3, 5 и 9. 
Запускается цикл пересчёта. Каждая итерация представляет собой усреднение элементов с индексами 
( i-1, j  ) ( i+1 , j ) ( i , j-1 ) ( i , j+1 ). Значения в квадратах и на границе не пересчитываються. 
Закончить цикл следует если max разницы между элементами прошлой и следующей сетки отличается не более чем на 1e-6.
Задача считается решённой если запросы coalesced.

Пример на 5.
Дан список из n строк в каждой из которых m наборов прямоугольников.
Решить задачу 4 на каждом из наборов, можно не соблюдать условия coalesced запросов.
Варианты условия:
1)Оформлять матрицу для набора на cpu, загружать её в отдельном stream потоке параллельно с вычислением. (всё в одном cpu потоке).
2)Выделить zero-copy память, создать два cpu потока, оформлять матрицу на одном cpu потоке, решать в другом cpu потоке используя gpu. Подумать о синхронизации.

